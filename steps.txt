 - basic shape with keyboard input example. OK
 - basic core of afk. OK
 - keyboard flyaround. OK
 - keyboard control of 3D object, making sure it behaves correctly.  (maybe make a simple camera-follow object...) OK
 - very basic points-grid landscape. OK
 - opencl example. OK
 - basic cubic cell landscape. OK
 - determine which cells to draw by camera facing. OK
 - landscape subdivision and LoD. OK
 - random number generator. OK
 - randomly distributed landscape in a grid (smallest cells only). OK
 - apply lighting to protagonist object. OK
 - triangular, lit landscape.  (no tessellation, just pre-defined triangle strips). OK
 - x/z only terrain, with horizontal LoD.  all terrain mated to the cells with y=0.  terrain of arbitrary height.  (expected glitch: when you can't see the floor, you can't see the terrain however high.  Unable to look up at mountains or down into troughs) OK
 - parallel evaluation via task queueing. OK
 - land map cache eviction; use constant memory OK
 - adjust detail pitch on the fly to maintain a framerate. OK
 - migrate terrain geometry to adjacent cells along the y-axis.  vertical terrain LoD.  OK, but needs changing (see todo_spilling.txt).  OK, changed it.
 - curved terrain (interpolated normals, curved terrain features). OK
 - basic instanced entities.  OK
 - within-cell collision detection between entities.
 - within-cell collision detection between entity and terrain.
 - protagonist as an entity.
 - proper protagonist/camera relationship (use quaternions to track orientation?  proper inverse matrix to get camera angle?) OK
 - use OpenCL to bake terrain.  mostly OK
 - optimised landscape rendering derived from the above. OK
 - shapes split into LoD cubes with random shapes.  (use OpenCL?) OK
 - actual entity LoD and stitched rendering. getting there
 - collision-based vertex lighting model.  ("collide" light source, travelling from origin, to target, with entities and terrain en route).
 - creation of entities by player.  See guns.txt.
 - consider destruction of entities upon collision.
 - save and load cell state.
 - share world across a network (synchronise seed, parameters that affect object generation).
 - share cell state across a network.
 - second protagonist on another networked node.
 - more than two nodes in the network.

